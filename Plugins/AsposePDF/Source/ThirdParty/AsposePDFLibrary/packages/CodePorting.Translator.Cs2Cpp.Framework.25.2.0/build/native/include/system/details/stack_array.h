#pragma once

#include <cstddef>
#include <cstdint>
#include <initializer_list>

#include <system/select_type.h>


namespace System { namespace Details {

    template<typename T, std::size_t ... NN>
    struct StackArray;


    /// Represents 1D array on the stack.
    /// Generated by the translator via attribute CodePorting.Translator.Cs2Cpp.CppArrayOnStack
    /// Partially mimic to System::ArrayPtr<T> interface.
    template<typename T, std::size_t N>
    struct StackArray<T, N>
    {
        using type_t = T[N];

        inline T& operator[] (std::size_t n) { return m_data[n]; }
        inline const T& operator[] (std::size_t n) const { return m_data[n]; }

        static const std::size_t size_ = N;
        constexpr std::size_t size() const noexcept { return size_; }
        constexpr std::size_t dims() const noexcept { return 1; }

        inline T * data() { return m_data; }
        inline const T * data() const { return m_data; }

        /// Returns 32-bit integer that represents the total number of all elements in all dimensions of the array.
        /// @returns Total number of all elements in all dimensions
        constexpr inline int32_t get_Length() const { return static_cast<int32_t>(size()); }

        /// Returns an iterator to the first element of the container.
        /// @returns An pointer to first element of the container.
        inline T* begin() noexcept
        {
            return m_data;
        }

        /// Returns an iterator to the element following the last element of the container.
        /// @returns An pointer to the theoretical element placed after the last element of the container.
        inline T* end() noexcept
        {
            return m_data + N;
        }

        /// Returns an iterator to the first element of the container.
        /// @returns An pointer to first element of the container.
        inline const T* begin() const noexcept
        {
            return m_data;
        }

        /// Returns an iterator to the element following the last element of the container.
        /// @returns An pointer to the theoretical element placed after the last element of the container.
        inline const T* end() const noexcept
        {
            return m_data + N;
        }

        /// Returns 'this' pointer. Needs for compatibility with the translator's code generator to avoid create special cases.
        /// @returns A 'this' pointer
        inline StackArray<T, N>* operator -> () { return this; }

        type_t m_data;
    };

    //...................................................................................

    /// Represents 1D array on the stack.
    /// Generated by the porter via the CodePorting.Translator.Cs2Cpp.CppArrayOnStack attribute
    /// Partially mimic to System::ArrayPtr<T> interface.
    template<std::size_t N>
    struct StackArray<bool, N>
    {
        StackArray(std::initializer_list<bool> init)
        {
            int n = 0;
            std::copy(init.begin(), init.end(), m_data);
        }

        /// Alias for the type used to represent each element of the array.
        using UnderlyingType = typename System::Details::SelectType<bool>::type;

        using type_t = UnderlyingType[N];

        inline UnderlyingType& operator[] (std::size_t n) { return m_data[n]; }
        inline const UnderlyingType& operator[] (std::size_t n) const { return m_data[n]; }

        static const std::size_t size_ = N;
        constexpr std::size_t size() const noexcept { return size_; }
        constexpr std::size_t dims() const noexcept { return 1; }

        inline UnderlyingType * data() { return m_data; }
        inline const UnderlyingType * data() const { return m_data; }

        /// Returns 32-bit integer that represents the total number of all elements in all dimensions of the array.
        /// @returns Total number of all elements in all dimensions
        constexpr inline int32_t get_Length() const { return static_cast<int32_t>(size()); }

        /// Returns an iterator to the first element of the container.
        /// @returns An pointer to first element of the container.
        inline UnderlyingType* begin() noexcept
        {
            return m_data;
        }

        /// Returns an iterator to the element following the last element of the container.
        /// @returns An pointer to the theoretical element placed after the last element of the container.
        inline UnderlyingType* end() noexcept
        {
            return m_data + N;
        }

        /// Returns an iterator to the first element of the container.
        /// @returns An pointer to first element of the container.
        inline const UnderlyingType* begin() const noexcept
        {
            return m_data;
        }

        /// Returns an iterator to the element following the last element of the container.
        /// @returns An pointer to the theoretical element placed after the last element of the container.
        inline const UnderlyingType* end() const noexcept
        {
            return m_data + N;
        }

        /// Returns 'this' pointer. Needs for compatibility with the porter code generator to avoid create special cases.
        /// @returns A 'this' pointer
        inline StackArray<bool, N>* operator -> () { return this; }

        type_t m_data;
    };

    //...................................................................................

    /// Represents ND array on the stack. (for future expanding CodePorting.Translator.Cs2Cpp.CppArrayOnStack attribute)
    /// Partially mimic to System::ArrayPtr<T> interface.
    template<typename T, std::size_t N, std::size_t ... NN>
    struct StackArray<T, N, NN...>
    {
        static_assert(N != 0, "At least one dimension should be defined!");

        using StackArray_1D = typename StackArray<T, NN...>::type_t;
        using type_t = StackArray_1D[N];

        inline StackArray_1D& operator[] (std::size_t n) { return m_data[n]; }
        inline const StackArray_1D& operator[] (std::size_t n) const { return m_data[n]; }

        static const std::size_t size_ = N * StackArray<T, NN...>::size_;
        constexpr std::size_t size() const noexcept { return size_; }
        constexpr std::size_t dims() const noexcept { return sizeof ...(NN) + 1; }

        inline T * data() { return reinterpret_cast<T*>(m_data); }
        inline const T * data() const { return reinterpret_cast<const T*>(m_data); }

        /// Returns 32-bit integer that represents the total number of all elements in all dimensions of the array.
        /// @returns Total number of all elements in all dimensions
        constexpr inline int32_t get_Length() const { return size(); }

        /// Returns 'this' pointer. Needs for compatibility with the translator's code generator to avoid create special cases.
        /// @returns A 'this' pointer
        inline StackArray<T, N, NN...>* operator -> () { return this; }

        type_t m_data;
    };

}}
